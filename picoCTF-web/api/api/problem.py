from api import common

__author__ = 'Collin Petty'
import json
import imp
import os
from os.path import basename
from stat import *

from api.common import cache
from api.annotations import *
from api import app
from pymongo.errors import DuplicateKeyError
from datetime import datetime

root_web_path = ""
relative_auto_prob_path = ""

auto_generators = dict()


def load_autogenerators():
    """Pre-fetch all autogenerators

    Pulls all problems from mongo where 'autogen' == True and then passes them one by one to load_autogenerator(p).
    """
    db = common.get_conn()
    print("Loading autogenerators")
    for prob in list(db.problems.find({'autogen': True})):
        if load_autogenerator(prob) is None:
            print("ERROR - load_autogenerator(prob) returned None for pid: " + prob['pid'])


def load_autogenerator(prob):
    """Loads an auto-generator from disk.

    Determines if the passed 'prob' variable is a problem dict from the db or simply a 'pid'. If it is a 'pid' the
    corresponding prob dict is queried. The generator code specified in the db is then loaded from disk and added
    to the table of generators if it has a callable 'generate' function. If the generator has a callable
    'validate_dependencies' function it is called prior to insertion.
    """
    db = common.get_conn()
    if 'pid' not in prob:  # Prob is a 'pid', not a 'prob'
        prob = db.problems.find_one({'pid': prob})
    generator = imp.load_source(prob['generator'][:-3], 'autogenerators/'+prob['generator'])
    if hasattr(generator, 'validate_dependencies') and callable(generator.validate_dependencies):
        if not generator.validate_dependencies():
            return None
    if hasattr(generator, 'generate') and callable(generator.generate):
        auto_generators[prob['pid']] = generator
        return generator
    return None


def move_temporary_files(file_list, desc):
    """Move files in the tmp directory.

    Takes a list of temporary files and a problem description. The files are enumerated and moved to the web
    auto-problems directory (publicly accessible) and performs a string substitution on the passed problem desc
    replacing the enumerated strings in the form ###file_X_url### with publicly accessible file path.
    """
    for idx, file_path in enumerate(file_list):
        file_name = basename(file_path)
        write_path = _full_auto_prob_path() + file_name
        print("Moving file %s to %s." % (file_path, write_path))
        os.rename(file_path, _full_auto_prob_path() + file_name)
        desc = desc.replace("###file_%s_url###" % str(idx + 1), "autoproblems/" + file_name)
        os.chmod(write_path, S_IWUSR | S_IRUSR | S_IRGRP | S_IROTH)
    return desc


def build_problem_instance(prob, uid):
    """Builds unique problem dependencies for an auto-generated problem.

    Gets the auto-generator instance for the passed problem and generates a problem instance. If no generator is found
    in the preloaded generator dict the generator script is loaded from the database. We then build the problem
    dependencies, grader, and description using the generator module. We move temporary files generated by the
    generator to the web path and perform description substitutions to enable external access to these resources.
    We then update the team document to specify that an auto-generated problem has been created for this team.
    """
    db = common.get_conn()
    generator = auto_generators.get(prob['pid'], None)
    if generator is None:
        print("Autogenerator for %s was not found in the precached list, rebuilding..." % prob['pid'])
        generator = load_autogenerator(prob['pid'])
        if generator is None:
            print("ERROR - load_autogenerator(pid) returned None for pid: " + prob['pid'])
    (file_list, grader, desc) = generator.generate()
    if file_list is not None:
        desc = move_temporary_files(file_list, desc)
    if prob['grader'] == "key":
        db.teams.update({'uid': uid}, {'$set': {'probinstance.'+prob['pid']: {'pid': prob['pid'],
                                                                              'desc': desc,
                                                                              'key': grader}}})
    elif prob['grader'] == 'script':
        db.teams.update({'uid': uid}, {'$set': {'probinstance.'+prob['pid']: {'pid': prob['pid'],
                                                                              'desc': desc,
                                                                              'grader': grader}}})
    return desc


def load_unlocked_problems(uid):
    """Gets the list of all unlocked problems for a team.

    First check for 'unlocked_<tid>' in the cache, if it exists return it otherwise rebuild the unlocked list.
    Query all problems from the database as well as all submissions from the current team.
    Cycle over all problems while looking at their weightmap, check to see if problems in the weightmap are solved.
    Increment the threshold counter for solved weightmap problems.
    If the threshold counter is higher than the problem threshold then add the problem to the return list (ret).
    """
    db = common.get_conn()
    unlocked = cache.get('unlocked_' + uid)  # Get the teams list of unlocked problems from the cache
    if unlocked is not None:  # Return this if it is not empty in the cache
        return json.loads(unlocked)
    unlocked = []
    team = db.teams.find_one({'uid': uid})
    if 'probinstance' not in team.keys():
        db.teams.update({'uid': uid}, {'$set': {'probinstance': {}}})
        team['probinstance'] = dict()
    correctPIDs = {p['pid'] for p in list(db.submissions.find({"uid": uid, "correct": True}))}
    for p in list(db.problems.find()):
        if 'weightmap' not in p or 'threshold' not in p or sum([p['weightmap'][pid] for pid in correctPIDs if pid in p['weightmap']]) >= p['threshold']:
            unlocked.append({'pid':            p['pid'],
                             'displayname':    p.get('displayname', None),
                             'hint':           p.get('hint', None),
                             'basescore':      p.get('basescore', None),
                             'correct':        True if p['pid'] in correctPIDs else False,
                             'desc':           p.get('desc') if not p.get('autogen', False)
                             else team['probinstance'][p['pid']].get('desc', None) if p['pid'] in team.get('probinstance', dict())
                             else build_problem_instance(p, uid)})

    unlocked.sort(key=lambda k: k['basescore'] if 'basescore' in k else 99999)
    cache.set('unlocked_' + uid, json.dumps(unlocked), 60 * 60)
    return unlocked


def get_solved_problems(uid):
    """Returns a list of all problems the team has solved.

    Checks for 'solved_<tid>' in the cache, if the list does not exists it rebuilds/inserts it.
    Queries the database for all submissions by the logged in team where correct == True.
    Finds all problems with a PID in the list of correct submissions.
    All solved problems are returned as a pid and display name.
    """
    db = common.get_conn()
    solved = cache.get('solved_' + uid)
    if solved is not None:
        return json.loads(solved)
    sPIDs = {d['pid'] for d in list(db.submissions.find({"uid": uid, "correct": True}))}
    probs = list(db.problems.find({"pid": {"$in": list(sPIDs)}}, {'pid': 1, 'displayname': 1, 'basescore': 1}))
    solved = sorted([{'pid': p['pid'],
                      'displayname': p.get('displayname', None),
                      'basescore': p.get('basescore', None)} for p in probs],
                    key=lambda k: k['basescore'] if 'basescore' in k else 99999,
                    reverse=True)
    cache.set('solved_' + uid, json.dumps(solved), 60 * 60)
    return solved


def get_single_problem(pid, uid):
    """Retrieve a single problem.

    Grab all problems from load_unlocked_problems (most likely cached). Iterate over the problems looking for the
    desired pid. Return the problem if found. If not found return status:0 with an error message.
    """
    for prob in load_unlocked_problems(uid):
        if prob['pid'] == pid:
            return prob
    return {'status': 0, 'message': 'Internal error, problem not found.'}


@app.route('/api/submit', methods=['POST'])
@return_json
@require_login
def submit_problem():
    """Handle problem submission.

    Gets the key and pid from the submitted problem, calls the respective grading function if the values aren't empty.
    If correct all relevant cache values are cleared. The submission is the inserted into the database
    (an attempt is made). A relevant message is returned if the problem has already been solved or the answer
    has been tried.
    """
    uid = session['uid']
    db = common.get_conn()
    pid = request.form.get('pid', '').strip()
    key = request.form.get('key', '').strip()
    correct = False
    if pid == '':
        return {"status": 0, "points": 0, "message": "Problem ID cannot be empty."}
    if key == '':
        return {"status": 0, "points": 0, "message": "Answer cannot be empty."}
    if pid not in [p['pid'] for p in load_unlocked_problems(uid)]:
        return {"status": 0, "points": 0, "message": "You cannot submit problems you have not unlocked."}
    prob = db.problems.find_one({"pid": pid})
    if prob is None:
        return {"status": 0, "points": 0, "message": "Problem ID not found in the database."}

    if not prob.get('autogen', False):  # This is a standard problem, not auto-generated
        (correct, message) = imp.load_source(prob['grader'][:-3], "./graders/" + prob['grader']).grade(uid, key)
    else:  # This is an auto-generated problem, grading is different.
        team = db.teams.find_one({'uid': uid})
        grader_type = prob.get('grader', 'script')
        if grader_type == 'script':
            (correct, message) = imp.load_source(team['probinstance'][pid]['grader'][:-3],
                                                 team['probinstance'][pid]['grader']).grade(uid, key)
        elif grader_type == 'key':
            correct = team['probinstance'][pid]['key'] == key
            message = prob.get('correct_msg', 'Correct!') if correct else prob.get('wrong_msg', 'Nope!')
    submission = {'uid': uid,
                  'timestamp': datetime.now(),
                  'pid': pid,
                  'ip': request.headers.get('X-Real-IP', None),
                  'key': key,
                  'correct': correct}
    if correct:
        cache.delete('unlocked_' + uid)  # Clear the unlocked problem cache as it needs updating
        cache.delete('solved_' + uid)  # Clear the list of solved problems
        cache.delete('teamscore_' + uid)  # Clear the team's cached score
        cache.delete('lastsubdate_' + uid)
        try:
            db.submissions.insert(submission)
        except DuplicateKeyError:
            return {"status": 0, "points": 0, "message": "You have already solved this problem!"}
    else:
        try:
            db.submissions.insert(submission)
        except DuplicateKeyError:
            return {"status": 0, "points": 0, "message": "You already tried that!"}
    return {"status": 1 if correct else 0, "points": prob.get('basescore', 0), "message": message}


def get_all_problems():
    db = common.get_conn()
    return [{'pid': p['pid'],
             'displayname': p['displayname'],
             'basescore': p['basescore'],
             'hardlock': p.get('hardlock', False),
             'ignorethresh': p.get('ignorethresh', False)} for p in db.problems.find({})]


def _full_auto_prob_path():
    return root_web_path + relative_auto_prob_path


@app.route('/api/problems', methods=['GET'])
@require_login
@return_json
@log_request
def load_unlocked_problems_hook():
    return load_unlocked_problems(session['uid'])


@app.route('/api/problems/solved', methods=['GET'])
@require_login
@return_json
@log_request
def get_solved_problems_hook():
    return get_solved_problems(session['uid'])


@app.route('/api/problems/<path:pid>', methods=['GET'])
@require_login
@return_json
@log_request
def get_single_problem_hook(pid):
    problem_info = get_single_problem(pid, session['uid'])
    if 'status' not in problem_info:
        problem_info.update({"status": 1})
    return problem_info
